<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Ground Truth – Refresh</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          sans-serif;
        margin: 0;
        padding: 2rem;
        background: #0f172a;
        color: #e2e8f0;
      }
      .card {
        max-width: 960px;
        margin: 0 auto;
        background: rgba(15, 23, 42, 0.92);
        border-radius: 0.75rem;
        padding: 2rem;
      }
      button {
        padding: 0.65rem 1.25rem;
        border: none;
        border-radius: 0.5rem;
        background: #2563eb;
        color: white;
        cursor: pointer;
        font-size: 1rem;
        margin-right: 0.5rem;
      }
      pre {
        background: rgba(15, 23, 42, 0.7);
        border-radius: 0.5rem;
        padding: 1rem;
        max-height: 320px;
        overflow: auto;
      }
      .summary-row {
        display: flex;
        flex-direction: column;
        padding: 0.5rem 0;
        border-bottom: 1px solid rgba(226, 232, 240, 0.15);
      }
      .summary-row.pass .summary-status {
        color: #4ade80;
      }
      .summary-row.fail .summary-status {
        color: #f87171;
      }
      .status[data-tone='error'] {
        color: #f87171;
      }
      .status[data-tone='success'] {
        color: #4ade80;
      }
      a {
        color: #93c5fd;
      }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>Ground Truth – Refresh</h1>
      <p>
        After running the Baseline harness, use this page to prove that native
        selections survive a refresh while transient sessions do not.
      </p>
      <ol>
        <li>Click <strong>Add Transient Selection</strong> and pick the fixture copy.</li>
        <li>
          (Optional) Click <strong>Verify – Expect Active</strong> to prove the
          transient lives while the tab stays open.
        </li>
        <li>
          Press <strong>F5 / Reload</strong>, then click
          <strong>Verify After Refresh</strong>. Native counts should match the
          manifest and transients should be cleared.
        </li>
      </ol>
      <p class="status" id="status">Idle</p>
      <div>
        <button id="addTransient">Add Transient Selection (this tab)</button>
        <button id="verifyActive">Verify – Expect Active</button>
        <button id="verifyAfterRefresh">Verify After Refresh (Expect Cleared)</button>
        <a href="ground_truth_reopen.html">Next: Reopen harness →</a>
      </div>
      <div id="summary"></div>
      <pre id="log">Waiting…</pre>
    </div>
    <script type="module">
      import fileStorageModule from '../../js/fileStorageModule.mjs';
      import { groundTruthCounts } from './fixtures/groundTruthManifest.js';
      import {
        setupHarness,
        compareCounts,
        createTransientPicker,
        assertTransientState
      } from './harness/harnessUtils.js';

      const harness = setupHarness();
      const addTransientBtn = document.getElementById('addTransient');
      const verifyActiveBtn = document.getElementById('verifyActive');
      const verifyAfterBtn = document.getElementById('verifyAfterRefresh');
      const pickTransient = createTransientPicker();

      const verify = async ({ expectTransientEmpty }) => {
        harness.setStatus('Verifying…');
        harness.resetSummary();
        try {
          await fileStorageModule.init();
          const keys = await fileStorageModule.listKeys({ includeTransient: false });
          if (!keys.length) {
            harness.report(
              'registry',
              false,
              'No native selections found – run baseline first.'
            );
          } else {
            const counts = await fileStorageModule.getFileCount(keys[0]);
            compareCounts({
              label: 'native.persistence',
              counts: counts.ok ? counts.counts : null,
              expected: groundTruthCounts,
              report: harness.report,
              includeHandles: true
            });
          }

          await assertTransientState({
            fileStorageModule,
            expectEmpty: expectTransientEmpty,
            report: harness.report,
            label: expectTransientEmpty
              ? 'transient.after-refresh'
              : 'transient.before-refresh'
          });
          harness.setStatus('Verification complete', 'success');
        } catch (error) {
          harness.report('refresh.error', false, error?.message ?? 'Unknown error');
          harness.setStatus('Verification failed', 'error');
          harness.log('refresh.error', {
            message: error?.message,
            stack: error?.stack
          });
        }
      };

      addTransientBtn.addEventListener('click', async () => {
        addTransientBtn.disabled = true;
        harness.setStatus('Awaiting transient selection…');
        try {
          const files = await pickTransient();
          const result = await fileStorageModule.add(files);
          if (!result.ok || result.storageType !== 'transient-session') {
            throw new Error(result.reason ?? 'Transient add failed');
          }
          compareCounts({
            label: 'transient.add',
            counts: result.counts,
            expected: groundTruthCounts,
            report: harness.report
          });
          harness.setStatus('Transient stored for this tab', 'success');
        } catch (error) {
          harness.report(
            'transient.persistEntries',
            false,
            error?.message ?? 'Selection cancelled'
          );
          harness.setStatus('Transient selection failed', 'error');
        } finally {
          addTransientBtn.disabled = false;
        }
      });

      verifyActiveBtn.addEventListener('click', () => {
        verifyActiveBtn.disabled = true;
        verify({ expectTransientEmpty: false }).finally(() => {
          verifyActiveBtn.disabled = false;
        });
      });

      verifyAfterBtn.addEventListener('click', () => {
        verifyAfterBtn.disabled = true;
        verify({ expectTransientEmpty: true }).finally(() => {
          verifyAfterBtn.disabled = false;
        });
      });

      harness.log('refresh.ready', {
        instructions: 'Run baseline first, then reload/verify from this page.'
      });
    </script>
  </body>
</html>
